/**
 * Realtime Connection Debugger
 * Utility for diagnosing and troubleshooting realtime connection issues
 */

import NetInfo from '@react-native-community/netinfo';
import { AppState, Platform } from 'react-native';
import { getConnectionStatus, forceReconnect } from '../services/realtimeService';
import { getUnseenNotificationCount } from '../services/notificationService';

// Diagnostic data collection
let diagnosticHistory = [];
const MAX_HISTORY_ENTRIES = 50;

const addDiagnosticEntry = (type, data) => {
  const entry = {
    timestamp: new Date().toISOString(),
    type,
    data,
    appState: AppState.currentState,
    platform: Platform.OS
  };
  
  diagnosticHistory.unshift(entry);
  
  // Keep only recent entries
  if (diagnosticHistory.length > MAX_HISTORY_ENTRIES) {
    diagnosticHistory = diagnosticHistory.slice(0, MAX_HISTORY_ENTRIES);
  }
  
  return entry;
};

// Comprehensive network and realtime status check
export const runDiagnostics = async () => {
  console.log('üîç Running Realtime Connection Diagnostics...');
  
  const diagnostics = {
    timestamp: new Date().toISOString(),
    platform: Platform.OS,
    appState: AppState.currentState,
    network: null,
    realtime: null,
    recommendations: []
  };

  try {
    // 1. Network connectivity check
    console.log('üì° Checking network connectivity...');
    const netInfo = await NetInfo.fetch();
    diagnostics.network = {
      isConnected: netInfo.isConnected,
      isInternetReachable: netInfo.isInternetReachable,
      type: netInfo.type,
      details: netInfo.details,
      isWifi: netInfo.type === 'wifi',
      isCellular: netInfo.type === 'cellular',
      isEthernet: netInfo.type === 'ethernet'
    };

    if (!netInfo.isConnected) {
      diagnostics.recommendations.push('‚ùå Pas de connexion r√©seau d√©tect√©e');
    } else if (netInfo.isInternetReachable === false) {
      diagnostics.recommendations.push('‚ö†Ô∏è Connexion r√©seau sans acc√®s Internet');
    } else if (netInfo.type === 'cellular' && netInfo.details?.cellularGeneration === '2g') {
      diagnostics.recommendations.push('‚ö†Ô∏è Connexion 2G d√©tect√©e - performances limit√©es');
    }

    // 2. Realtime connection status
    console.log('üîå Checking realtime connection status...');
    const realtimeStatus = getConnectionStatus();
    diagnostics.realtime = realtimeStatus;

    if (!realtimeStatus.isConnected) {
      if (realtimeStatus.reconnectAttempts > 0) {
        diagnostics.recommendations.push(
          `üîÑ Reconnexion en cours (${realtimeStatus.reconnectAttempts}/${realtimeStatus.maxReconnectAttempts})`
        );
      } else {
        diagnostics.recommendations.push('‚ùå Connexion temps r√©el inactive');
      }
    }

    if (realtimeStatus.activeSubscriptionsCount === 0) {
      diagnostics.recommendations.push('‚ö†Ô∏è Aucune souscription active d√©tect√©e');
    }

    // 3. App state check
    if (AppState.currentState !== 'active') {
      diagnostics.recommendations.push('‚ÑπÔ∏è Application en arri√®re-plan - connexions paus√©es');
    }

    // 4. Platform-specific checks
    if (Platform.OS === 'ios') {
      diagnostics.recommendations.push('‚ÑπÔ∏è iOS: V√©rifiez les permissions r√©seau dans R√©glages');
    } else if (Platform.OS === 'android') {
      diagnostics.recommendations.push('‚ÑπÔ∏è Android: V√©rifiez l\'√©conomiseur de batterie');
    }

    // 5. Connection test
    console.log('üß™ Testing basic connectivity...');
    try {
      const testResponse = await fetch('https://httpbin.org/get', {
        method: 'HEAD',
        timeout: 5000
      });
      diagnostics.connectionTest = {
        success: testResponse.ok,
        status: testResponse.status,
        statusText: testResponse.statusText
      };
      
      if (!testResponse.ok) {
        diagnostics.recommendations.push('‚ùå Test de connectivit√© √©chou√©');
      }
    } catch (error) {
      diagnostics.connectionTest = {
        success: false,
        error: error.message
      };
      diagnostics.recommendations.push('‚ùå Impossible de joindre les serveurs externes');
    }

    // Add final recommendations
    if (diagnostics.recommendations.length === 0) {
      diagnostics.recommendations.push('‚úÖ Aucun probl√®me d√©tect√©');
    } else {
      diagnostics.recommendations.push('üí° Essayez de red√©marrer l\'application si les probl√®mes persistent');
    }

  } catch (error) {
    console.error('Error running diagnostics:', error);
    diagnostics.error = error.message;
    diagnostics.recommendations.push('‚ùå Erreur lors du diagnostic');
  }

  // Log comprehensive results
  console.log('üìä Diagnostic Results:', diagnostics);
  
  // Add to history
  addDiagnosticEntry('full_diagnostic', diagnostics);
  
  return diagnostics;
};

// Quick connection health check
export const quickHealthCheck = async () => {
  const netInfo = await NetInfo.fetch();
  const realtimeStatus = getConnectionStatus();
  
  const health = {
    overall: 'healthy',
    network: netInfo.isConnected && netInfo.isInternetReachable !== false,
    realtime: realtimeStatus.isConnected,
    appState: AppState.currentState === 'active'
  };

  if (!health.network) {
    health.overall = 'network_issues';
  } else if (!health.realtime) {
    health.overall = 'realtime_issues';
  } else if (!health.appState) {
    health.overall = 'background';
  }

  addDiagnosticEntry('health_check', health);
  return health;
};

// Force reconnection with diagnostics
export const diagnosticReconnect = async () => {
  console.log('üîÑ Initiating diagnostic reconnection...');
  
  const preReconnectDiagnostics = await quickHealthCheck();
  addDiagnosticEntry('reconnect_attempt', { phase: 'before', ...preReconnectDiagnostics });
  
  try {
    await forceReconnect();
    
    // Wait a bit for the reconnection to take effect
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    const postReconnectDiagnostics = await quickHealthCheck();
    addDiagnosticEntry('reconnect_attempt', { phase: 'after', ...postReconnectDiagnostics });
    
    return {
      success: true,
      before: preReconnectDiagnostics,
      after: postReconnectDiagnostics
    };
  } catch (error) {
    addDiagnosticEntry('reconnect_error', { error: error.message });
    return {
      success: false,
      error: error.message,
      before: preReconnectDiagnostics
    };
  }
};

// Get diagnostic history
export const getDiagnosticHistory = () => {
  return [...diagnosticHistory];
};

// Clear diagnostic history
export const clearDiagnosticHistory = () => {
  diagnosticHistory = [];
  console.log('üóëÔ∏è Diagnostic history cleared');
};

// Export summary for debugging
export const exportDiagnosticSummary = () => {
  const summary = {
    timestamp: new Date().toISOString(),
    platform: Platform.OS,
    appState: AppState.currentState,
    historyCount: diagnosticHistory.length,
    recentIssues: diagnosticHistory
      .filter(entry => entry.type !== 'health_check')
      .slice(0, 10),
    connectionPattern: diagnosticHistory
      .filter(entry => entry.type === 'health_check')
      .slice(0, 20)
      .map(entry => ({
        timestamp: entry.timestamp,
        overall: entry.data.overall
      }))
  };
  
  console.log('üìã Diagnostic Summary Export:', summary);
  return summary;
};

// Monitor connection and log issues automatically
let isMonitoring = false;
let monitoringInterval = null;

export const startConnectionMonitoring = (intervalMs = 30000) => {
  if (isMonitoring) {
    console.log('üîç Connection monitoring already active');
    return;
  }
  
  isMonitoring = true;
  console.log(`üîç Starting connection monitoring (every ${intervalMs}ms)`);
  
  monitoringInterval = setInterval(async () => {
    if (AppState.currentState === 'active') {
      const health = await quickHealthCheck();
      
      // Only log if there are issues
      if (health.overall !== 'healthy') {
        console.warn('‚ö†Ô∏è Connection issue detected:', health);
      }
    }
  }, intervalMs);
};

export const stopConnectionMonitoring = () => {
  if (!isMonitoring) {
    return;
  }
  
  isMonitoring = false;
  if (monitoringInterval) {
    clearInterval(monitoringInterval);
    monitoringInterval = null;
  }
  
  console.log('üõë Connection monitoring stopped');
};

/**
 * Debug utility for monitoring realtime notification system
 */
export class RealtimeDebugger {
  constructor() {
    this.isDebugging = __DEV__; // Only enable in development
    this.logs = [];
    this.maxLogs = 100;
  }

  log(message, data = null) {
    if (!this.isDebugging) return;
    
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      message,
      data: data ? JSON.stringify(data, null, 2) : null
    };
    
    this.logs.unshift(logEntry);
    if (this.logs.length > this.maxLogs) {
      this.logs = this.logs.slice(0, this.maxLogs);
    }
    
    console.log(`[RealtimeDebug] ${timestamp}: ${message}`, data || '');
  }

  async checkNotificationSystemHealth(userId) {
    if (!this.isDebugging) return;
    
    this.log('=== Notification System Health Check ===');
    
    try {
      // Check connection status
      const connectionStatus = getConnectionStatus();
      this.log('Connection Status', connectionStatus);
      
      // Check unseen notification count
      const unseenCount = await getUnseenNotificationCount(userId);
      this.log('Current unseen count from database', { unseenCount });
      
      // Check if realtime is working
      this.log('Realtime connection details', {
        isConnected: connectionStatus.isConnected,
        reconnectAttempts: connectionStatus.reconnectAttempts,
        activeSubscriptions: connectionStatus.activeSubscriptionsCount,
        appState: connectionStatus.appState
      });
      
      if (!connectionStatus.isConnected) {
        this.log('‚ö†Ô∏è WARNING: Realtime connection is not active');
      }
      
      if (connectionStatus.activeSubscriptionsCount === 0) {
        this.log('‚ö†Ô∏è WARNING: No active subscriptions found');
      }
      
      this.log('=== Health Check Complete ===');
      
    } catch (error) {
      this.log('‚ùå ERROR during health check', error);
    }
  }

  getLogs() {
    return this.logs;
  }

  clearLogs() {
    this.logs = [];
    this.log('Logs cleared');
  }

  printSummary() {
    if (!this.isDebugging) return;
    
    console.log('\n=== REALTIME DEBUG SUMMARY ===');
    console.log(`Total log entries: ${this.logs.length}`);
    
    const recentLogs = this.logs.slice(0, 10);
    console.log('Recent logs:');
    recentLogs.forEach((log, index) => {
      console.log(`${index + 1}. ${log.timestamp}: ${log.message}`);
    });
    
    console.log('=== END SUMMARY ===\n');
  }
}

// Create singleton instance
export const realtimeDebugger = new RealtimeDebugger();

// Export utility functions
export const debugNotificationSystem = (userId) => {
  return realtimeDebugger.checkNotificationSystemHealth(userId);
};

export const logRealtimeEvent = (message, data) => {
  realtimeDebugger.log(message, data);
};

export const getDebugLogs = () => {
  return realtimeDebugger.getLogs();
};

export const clearDebugLogs = () => {
  realtimeDebugger.clearLogs();
}; 